# L(arge) M(emory) LOGS Library

## What is it ?
Header-Only C Library providing an in-memory expandable log stack that hopes to reduce I/O time overhead of logging during CPU intensive tasks.
Using lmlogs allows avoiding the slowdown encountered when repeatedly using I/O based logs like fprintf by storing a customizable and primitive representation of the logs information in RAM until we have time to output the logs somewhere else (like a file) or process it.

## Example use case
I want to record some information about a CPU intensive task and use the information later. The task is limited in time (not infinitely repeating) or is interspersed (meaning at some point, regularly the task does not need run) so that the logs can be dumped somewhere / processed.

## Naming

#### Log
A log is a structure containing a reference to the head and tail of the stack list.
It also contains the number of blocks currently in the list.

#### Stack
A stack is a structure containing multiple log entries.
It has a capacity (number of entries it can contain), a size (current count of entries in the stack) and a pointer to the next stack (if any).
This means that stacks are stored as a linked-list.

#### Entry
An entry is a user defined structure, unique (most of the time) for each log type (not instance).
It contains the basic information the user wants to store.

## Using lmlogs

### Declaring a new log type

#### The `LML_DECLARE_LOG` macro
```C
#define LML_DECLARE_LOG(PREFIX, TYPE, PREV_OPT, MEMSIZE_OPT, CLEARABLE_OPT, FIELDS...)
```
#### Example use: 
```C
LML_DECLARE_LOG(myprefix, struct mystruct, LML_NO_OPT, LML_NO_OPT, {
    uint64_t timestamp;
    uint64_t data;
    // etc ...
});
```

#### What is happening here ?
The `LML_DECLARE_LOG` generates code for a new log type. In order to do that, lmlogs creates a new type `struct mystruct_entry` with fields `uint64_t timestamp` and `uint64_t data` which will be the primitive data stored by the log.
Multiple functions and structures will also be generated by the macro. They will allow use to create log instances, push data to them and dump their content. Those elements' names will start with the prefix `myprefix`, e.g.:
* structures : 
  * `myprefix_log` : a log instance (a chain of blocks + some info about the instance)
  * `myprefix_stack` : a block in the log instance block chain containing multiple log entries
* functions :
  * `myprefix_log_new`
  * `myprefix_stack_new`
  * ...

NB : because the functions names are different for each type, we will, from now on, use `PREFIX=myprefix` and `TYPE=struct mystruct` for the given examples

### Making a log instance

#### The `PREFIX_log_new` function
```C
struct PREFIX_log *PREFIX_log_new(size_t stack_cap)
```

#### Example use
```C
struct myprefix_log* log = myprefix_log_new(4096);
```
Will allocate a log and a block of size 4096. This size represents the number of entries contained in a block and will be the capacity of the future blocks allocated when the first one is full.


### Pushing to the log

#### The `PREFIX_log_push` function
```C
TYPE_entry *PREFIX_log_push(struct PREFIX_log *log, TYPE_entry entry)
```

#### Example use
```C
myprefix_log_push(log, (struct mystruct_entry) {
                  .timestamp = 0,
                  .data = 69
          });
```
because this function returns a pointer to the copy of the struct given in the log, we can store the time after insertion like this:

```C
myprefix_log_push(log, (struct mystruct_entry) {
                  .timestamp = 0,
                  .data = 69
          })->timestamp = some_function_giving_time();
```

#### What is happening here ?
lmlogs finds the next spot in the log stack list and copies the given struct data into it. If the log tail stack is full, it allocates a new one using the capacity of the last stack of the log chain
It then returns a pointer to the entry in the log stack

### Dumping the log's content

#### The `myprefix_log_dump` function
```C
void PREFIX##_log_dump(
        struct PREFIX##_log *log, 
                void (*consumer)(
                        struct PREFIX##_log* log, 
                        struct PREFIX##_stack* stack, 
                        size_t index, 
                        TYPE##_entry *entry, 
                        void *extra), 
                void *extra
                )
```

#### Example use

Open a file
```C
FILE *dump_file = fopen("./dump.log", "w");
```

Declare a stack entry consumer
```C
void put_entry_to_file(
      struct myprefix_log *log, 
      struct myprefix_stack *stack, 
      size_t index, 
      struct mystruct_entry* entry, 
      void *file_extra
) {
    FILE *file = (FILE *)file_extra;
    fprintf(file, "[%lu] data=%lu\n", entry->timestamp, entry->data);
}

```

Dump the log's content using the consumer
```C
myprefix_log_dump(log, put_entry_to_file, (void *)dump_file);
```

#### What is happening here ?
`myprefix_log_dump` takes as argument a log to dump, a consumer and an *extra*.
The consumer is a function that will be called for each entry in the log with the following parameters:
* a pointer to the `myprefix_log` being dumped
* a pointer to the `myprefix_stack` in which the current entry is
* a `size_t` value representing the index of the entry in its stack (useful to compare values with previous / next log entry)
* a pointer to the `struct mystruct_entry` to dump during this call
* a `void*` pointer to the *extra* given to the consumer in the initial `myprefix_log_dump`

Here the extra is a file handle but it could be a file descriptor, anything else, or nothing, the only element using the extra is the consumer and is 100% controlled by the user. 
This function is where the slower I/O part has been deferred. Dumping a big log stack is long and should be done when there's nothing else to do.


### Freeing the log

#### The `myprefix_log_free` function
```C
void myprefix_log_free(struct myprefix_log *log)
```

#### Example use
```C
lml_log_free(log);
```

Will free the entirety of the allocated memory for this log instance.

## lmlogs options
lmlogs uses rudimentary macro tricks (with the `LML_COND` macro) to allow custom code generation based on the user's needs.
When declaring a new log you can specify the options you want to include in your new log type and the required code for this option to work will be generated for this new log type only.
If you don't want to use an option, just put `LML_NO_OPT` instead of the option's flag 

### Available options
#### The `LML_PREV_OPT` option
Makes the log stack a double linked list, allowing the user to iterate manually through the log stack in both directions.
Adds a `struct PREFIX_stack *prev` field to the `struct PREFIX_stack` structure and a bit of logic during the `PREFIX_log_expand(...)` that adds a new stack to the log.

#### The `LML_RECORD_MEMSIZE_OPT` option
Adds a `size_t alloc_size` field to the `struct PREFIX_log` structure. This fields contains the number of bytes allocated to this log instance.
Adds a bit of code in the `PREFIX_log_expand(...)` function and to the structure allocating functions aswell.

#### The `LML_CLEAR_OPT` option
Makes the log stack clearable without freeing memory for reuse after dumping.
Adds a `struct PREFIX_stack *curr` field to the `struct PREFIX_log` that keeps track of which stack to insert into next. 
Indeed, after a clear, a log can have multiple allocated stacks even though we're starting to write on the head stack again. 
This means that with the `LML_CLEAR_OPT` the tail is not always the stack to insert new logs into.
The user can clear a log using the `PREFIX_log_clear(struct PREFIX_log *log)` function.

## Demo and benchmark
See the `main.c` file which compares the lmlogs performance against the basic approach of using fprintf whenever we have something to log.
You can notice that the overall execution takes longer using lmlogs but msot importantly that the part where important CPU intensive code would be ran is considerably less impacted by lmlogs's memory logging system than by the basic approach. 
Indeed, dumping could be done only at the end of the program's execution which is not something we need to be especially quick in most cases.
